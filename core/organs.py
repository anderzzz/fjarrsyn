'''All organ classes of the basic Agent are contained in this file.

'''
import copy

from core.naturallaw import ObjectMapCollection
from core.message import Buzz, Direction, Feature, Belief
from core.scaffold import Resource, ResourceMap

class _Organ(object):
    '''Organ parent class, which defines common structure and method for all
    organs. 

    Parameters
    ----------
    organ_name : str
        Name of the organ
    message_input : str, or _Message
        Instance of message the organ deals with as input 
    organ_function : callable
        The function that upon execution performs the operations of the organ
    message_output : str, or _Message
        Instance of message the organ deals with as output
    function_kwargs : dict, optional
        Any arguments needed for the organ_function

    '''
    def __init__(self, organ_name, message_input, organ_function,
                 message_output, function_kwargs={}):

        if not callable(organ_function):
            raise TypeError('Organ requires callable function for its operation')

        self.name = organ_name
        self.message_input = message_input
        self.organ_func = organ_function
        self.message_output = message_output
        self.kwargs = function_kwargs

class Sensor(_Organ):
    '''Sensor class, which defines how a precept of the external World is
    turned into buzz within the agent.

    Parameters
    ----------
    name : str
        Name of sensor
    precept_name : str
        Name of the precept of the World to interact with
    sensor_func : callable
        Callable function that upon execution reads precept and returns the
        buzz dictionary
    buzzkeys : list
        List of strings for the buzz names that the sensor generates, must be
        identical to the keys for the dictionary returned by the `sensor_func`
    kwargs : dict, optional
        Named arguments for the `sensor_func`

    '''
    def __str__(self):
        '''Print string for sensor object

        '''
        ret = 'Sensor %s for precept %s.' %(self.name, self.message_input)
        return ret

    def __call__(self, agent_index):
        '''Execute the sensor function with check that buzz output conforms to
        expected shape.

        Returns
        -------
        buzz : dict
            The buzz generated by the Sensor as it interacts with environment

        Raises
        ------
        ValueError
            If the sensor function returns a buzz dictionary with keys that do
            not match the buzz keys defined during sensor initialization.

        '''
        kwargs = copy.copy(self.kwargs)
        kwargs['agent_index'] = agent_index

        vals = self.organ_func(**kwargs)
        self.message_output.set_elements(vals)

        return True

    def __init__(self, name, precept_label, sensor_func, buzz, sensor_func_kwargs={}):

        if not isinstance(precept_label, str):
            raise TypeError('Sensor input should be string')

        if not isinstance(buzz, Buzz):
            raise TypeError('Sensor output should be of class Buzz')

        super().__init__(name, precept_label, sensor_func, 
                         buzz, sensor_func_kwargs)

class Actuator(_Organ):
    '''Actuator class, which defines how an action by the agent alters the
    external world.

    Parameters
    ----------
    name : str
        Name of the actuator
    action_name : str
        Name of the action to act on the World
    actuator_func : callable
        Callable function that upon execution alters the World. The function
        does not have to return anything
    keys2populate : list
        Container of names of the arguments to the callable function that
        define the specific action. This list should exclude any agent
        identifier, which declares where in the World the action is applied.
    agent_index : str
        Agent index in the World onto which the action should be applied

    '''
    def __call__(self, agent_index):
        '''Execute the actuator function and alter the World

        Notes
        -----
        The actuator can only be executed after the actuator has been
        populated, which is done with the `populate` method

        Raises
        ------
        RuntimeError
            In case the actuator is executed prior to population

        '''
        kwargs = copy.copy(self.kwargs)
        kwargs['agent_index'] = agent_index

        direction_values = self.message_input.read_value()

        out_values = self.organ_func(*direction_values, **kwargs)

        if self.resource_map is None:
            pass

        else:
            self.resource_map.set_elements(out_values)

        return True

    def __init__(self, name, direction, actuator_func, action_label,
                 resource_map=None, actuator_func_kwargs={}):

        if not isinstance(direction, Direction):
            raise TypeError('Actuator input should be instance of class Direction')

        if not resource_map is None:
            if not isinstance(resource_map, ResourceMap):
                raise TypeError('Actuator resource maps should be of class ResourceMap')

        super().__init__(name, direction, actuator_func, 
                         action_label, actuator_func_kwargs)

        self.resource_map = resource_map 

class Interpreter(_Organ):
    '''Interpreter class, which defines how buzz from a sensor is made into
    persistent beliefs of the agent.

    Parameters
    ----------
    name : str
        Name of the interpreter
    buzz_names : list
        Container of names of the buzz to be interpreted. Must correspond with
        the output from the relevant sensor
    interpreter_func : callable
        Callable function that upon execution computes and assigns belief given
        the buzz input
    kwargs : dict, optional
        Any arguments other than the buzz needed in order to execute the
        interpreter function

    '''
    def __call__(self):
        '''Execute the interpreter function

        Parameters
        ----------
        buzz : dict
            The buzz values from the relevant sensor

        Returns
        -------
        belief_updated : list
            List of keys to the beliefs that were updated following the
            interpretation

        '''
        buzz_values = self.message_input.read_value()

        if self.belief_updater:
            current_beliefs = self.message_output.read_value()
            args = (current_beliefs, buzz_values)

        else:
            args = (buzz_values,)

        value = self.organ_func(*args, **self.kwargs)

        self.message_output.set_elements(value)

        return True 

    def __init__(self, interpreter_name, buzz, interpreter_func, belief,
                 belief_updater=False, kwargs={}):

        if not isinstance(buzz, Buzz):
            raise TypeError('Interpreter input should be of class Buzz')

        if not isinstance(belief, Belief):
            raise TypeError('Interpreter output should be of class Belief')

        super().__init__(interpreter_name, buzz, interpreter_func, 
                         belief, kwargs)

        self.belief_updater = belief_updater

class Moulder(_Organ):
    '''Moulder class, which defines how beliefs are turned into an executable
    instance of an actuator.

    Parameters
    ----------
    name : str
        Name of moulder
    belief_names : list
        Container of belief labels that the moulder engages with
    moulder_func : callable
        Callable function that upon execution processes agent belief and
        scaffold into a complete set of parameters to be used to populate an
        actuator
    kwargs : dict, optional
        Named arguments for the `moulder_func`

    '''
    def __call__(self):
        '''Execute the moulder to populate an actuator

        Notes
        -----
        After excecution of the moulder the actuator can be executed. Prior to
        moulding the actuator is form without content.

        Parameters
        ----------
        belief : dict
            Dictionary of belief values, at least a subset of which overlaps
            with the belief names defined during initialization
        actuator
            The actuator instance to populate. If not defined the moulder is
            executed expecting only to create an object force output

        '''
        belief_values = self.message_input.read_value()

        out_values = self.organ_func(*belief_values, **self.kwargs)

        if self.resource_map is None:
            self.message_output.set_elements(out_values)

        else:
            self.message_output.set_elements(out_values[0])
            self.resource_map.set_elements(out_values[1]) 

        return True

    def __init__(self, moulder_name, belief, moulder_func, direction,
                 resource_map=None, moulder_func_kwargs={}):

        if not isinstance(belief, Belief):
            raise TypeError('Moulder input should be of class Belief')

        if not isinstance(direction, Direction):
            raise TypeError('Moulder output should be of class Direction')

        if not resource_map is None:
            if not isinstance(resource_map, ResourceMap):
                raise TypeError('Moulder resource maps should be of class ResourceMap')

        super().__init__(moulder_name, belief, moulder_func, 
                         direction, moulder_func_kwargs)

        self.resource_map = resource_map 

class Cortex(_Organ):
    '''Cortex class, which defines reaction to a certain tickle from the World.
    The Cortex is separate from beliefs and depend only on scaffold

    Parameters
    ----------
    name : str
        Name of cortex
    tickle_name : str
        Name of the kind of external tickling that the cortex responds to
    cortex_func : callable
        Callable function that upon execution returns a value of some sort that
        at most can depend on the agent scaffold.
    kwargs : dict, optional
        Named arguments for the `cortex_func`

    '''
    def __call__(self):
        '''Execute the cortex

        Returns
        -------
        value
            Return value as the cortex is tickled.

        '''
        scaffold_values = self.message_input.read_value()

        out_values = self.organ_func(*scaffold_values, **self.kwargs)
        self.message_output.set_elements(out_values)

        return self.message_output

    def __init__(self, cortex_name, scaffold, cortex_func, feature,
                 cortex_func_kwargs={}):

        super().__init__(cortex_name, scaffold, cortex_func, feature,
                         cortex_func_kwargs)
